#!/usr/bin/perl

use strict;
use warnings;
use File::chdir;
use File::Path qw(make_path);
use Time::HiRes qw(gettimeofday tv_interval);

my $sets_dir; #path where to download sets
my $simulation = "no";

SETS: {
	$sets_dir = "$ENV{'HOME'}/OpenBSD";
	printf "Path to download sets? (or 's'imulation ) [$sets_dir] ";
	my $line = <STDIN>;
	chomp($line);
	if ($line eq "s") {
		$simulation = "yes";
		last SETS;
	} elsif ($line) {
		$sets_dir = $line;
	} 
	if (! -d $sets_dir) {
		make_path($sets_dir) or print "$!\n";
	}
	(! -d $sets_dir ) ? redo SETS : last SETS;
}

$CWD = $sets_dir;

my $hw;

my @platforms = ( "alpha",
		  "amd64",
		  "armish",
		  "hp300",
		  "hppa",
		  "i386",
		  "landisk",
		  "loongson",
		  "macppc",
		  "mvme68k",
		  "mvme88k",
		  "sgi",
		  "socppc",
		  "sparc",
		  "sparc64",
		  "vax",
		  "zaurus" );

HW: {
	$hw = `uname -m`;
	chomp($hw);
	printf "Platform? (or 'list') [$hw] ";
	my $line = <STDIN>;
	chomp($line);
	if ($line eq 'list') {
		print "Avaible Platforms:\n";
		for (@platforms) {
			print "    $_\n";
		}
		redo HW;
	} elsif ($line) {
		if ((grep {/$line/} @platforms) == 1) {
			$hw = $line;
			last HW;
		} else {
			printf "bad hardware platform name\n";
			redo HW;
		}
	}
}

my $SHA256_location = "http://ftp.OpenBSD.org/pub/OpenBSD/snapshots/$hw/SHA256";
print "Downloading $SHA256_location... ";
my $SHA256 = `curl -s $SHA256_location`;
print "Done\n";

if ( $SHA256 =~ /base([0-9]{2,2}).tgz/ ) {
	my $r = $1;
} else {
	die "No good SHA256 from http://ftp.OpenBSD.org. Aborting.\n";
}

print "Getting mirror list from http://www.openbsd.org/ftp.html\n";
my @ftp_html = split /\n/, `curl -s http://www.openbsd.org/ftp.html`; 
my @servers;
my @synced_server;

for (@ftp_html) {
	if (/^\s+((http:)\/\/.+)</ && (! /ftp\.OpenBSD\.org/)) {
		push @servers, $1;
	}
}

my %synced_mirror; # { 'http://mirror.com' => $time }

print "Let's locate mirrors synced with ftp.OpenBSD.org (this may take some time)\n";

for my $candidat_server (@servers) {
	my $url = "${candidat_server}snapshots/$hw/SHA256";
	$candidat_server =~ s!pub/OpenBSD/!!;
	my $time_before_dl = [gettimeofday];
	my $mirrored_SHA256 = `curl -s -m 1 $url 2>/dev/null`;
	my $time = tv_interval $time_before_dl;
	if ($SHA256 eq $mirrored_SHA256) {
		$synced_mirror{$candidat_server} = $time ;
	}
}

my $server;
my @sorted_mirrors = sort {$synced_mirror{$a} <=> $synced_mirror{$b}} keys %synced_mirror;

MIRROR: {
	print "Mirror? (or 'list') [$sorted_mirrors[0]] ";
	my $line = <STDIN>;
	chomp ($line);
	if ($line eq "list") {
		print "Synced mirrors from the fastest to the slowest:\n";
		for (@sorted_mirrors) {
			print "    $_\n";
		}
		print "";
		redo MIRROR;
	} elsif ($line eq "") {
		$server = $sorted_mirrors[0];
		last MIRROR;
	} elsif ((grep {/^$line$/} @sorted_mirrors) == 1) {
		$server = $line;
		last MIRROR;
	} else {
		print "Bad mirror string '$line'\n";
		redo MIRROR;
	}
}


my $checked_set_pattern = "^INSTALL|^bsd|^base|^comp|^etc|^game|^man|^man|^misc|^x";
my @sets;

for (split /\n/s, $SHA256) {
	my $set = (/\((.*)\)/) ? $1 : die "Weird SHA256\n";
	my $status = ($set =~ $checked_set_pattern) ? "checked" : "not checked";
	push @sets, { $set => $status };
}

SETS: {
	print "Sets available:\n";
	for (@sets) {
		for my $key (keys %{$_}) {
			my $box = ($_->{$key} eq "checked") ? "[x]" : "[ ]";
			print "$box $key\n";
		}
	}
	printf "Set names? (or 'done') [done] ";
	my $line = <STDIN>;
	chomp($line);
	my $operation;
	my $pattern;
	if ($line eq "done" or $line eq "") {
		last SETS;
	} else {
		if ($line =~ /(\+|-)(.+)/) {
			$operation = $1;
			$pattern = $2;
		} else {
			print "+re add sets with pattern re\n-re remove sets with pattern re\n";
			redo SETS;

		}
		for my $set_ref (@sets) {
			for my $set (keys %{$set_ref}) {
				if ($set =~ /$pattern/
				    && $operation eq '-') {
					$set_ref->{$set} = "not checked";
				} elsif ($set =~ /$pattern/
					 && $operation eq '+') {
					$set_ref->{$set} = "checked";
				}
			}
		}
		redo SETS;
	}
}

print "OK let's get the sets from $server!\n";

my @stripped_SHA256; #SHA256 stripped from undownloaded sets

for my $set_ref (@sets) {
	for my $set (keys %{$set_ref}) {
		if ($set_ref->{$set} eq "checked") {
			print "curl -o $set $server/pub/OpenBSD/snapshots/$hw/$set\n";
			if ($simulation eq "no") {
				`curl -o $set $server/pub/OpenBSD/snapshots/$hw/$set`;
				if ($SHA256 =~ /(SHA256 \($set\) = [a-f0-9]+\n)/s) {
					push @stripped_SHA256, $1;
				}
			}
		}
	}
}
if ($simulation eq "no") {
	open my $fh_SHA256, '>', 'SHA256';
	print $fh_SHA256 @stripped_SHA256;
	
	print "Checksum:\n" . `cksum -a sha256 -c SHA256` ;
}
